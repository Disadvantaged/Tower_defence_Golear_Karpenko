TOWER DEFENSE

Смысл игры: По дороге идут противники, желающие дойти до финиша.
            Игрок ставит башни, который убивают противников.
            Необходимо уничтожить все волны врага.

Реализация: Для создания игры был использован модуль PyGame.
            В начале игры создается объект класса Game.
            В него загружается вся информация, также загружается игровое поле.
            Базовым классом и основой всей игры является класс Rectangle,
            который позволяет отображать на экране все объекты.
            
            Класс World служит для создания мира, дороги. Мир состоит из клеток
            различного типа: трава, камни, дорога и указатели пути для врагов.
            Для создания игрового мира использовался паттерн "Фабричный метод".
            Этот паттерн позволил легко создавать клетки, имеющие различные
            параметры.
            Игровая карта состоит из чисел(0-3), где каждое число отвечает своей
            клетке. В мире игры есть массив фабрик, каждая из которых производит
            клетку определенного типа в зависимости от числа.
            
            Игрок может располагать свои башни только на
            клетках с травой.
            Башни было задумано читать из специального файла для того, чтобы их
            можно было настраивать и, к примеру, для определенного уровня
            загружать другие башни.
            При создании башен применяется паттерн "Строитель". Его
            использование позволило легко создавать и изменять башни, меняя
            всего лишь конфиг с башнями.

            Всеми монстрами управляет один общий класс, EnemyController.
            Для создания монстров будет также применен паттерн "Фабричный
            метод", так как с его помощью можно легко создавать различные типы
            одних и тех же объектов.

К заданию 2:Для создания необходимого интерфейса использован паттерн Компоновщик:
            1) он неявно используется в pygame.sprite.Groups - объединяет спрайты и вызывает для них апдейт
            2) использован в enemy_controller - класс enemy_controller создает, объединяет врагов
            и вызывает для них апдейт.

            Применен структурный паттерн Заместитель:
            Написан свой класс Rect, который при необходимости перейти с pygame заместит pygame.Rect
            Аналогично с классом Sprite.

К заданию 3: Использован паттерн Медиатор:
             Класс Game cлужит посредником для всех остальных

             Задействован поведенческий паттерн Command:
             Класс Button хранит в себе "объект-команду", которая вызывается при вызове соответствующего класса.

             Применен паттерн Observer:
            Enemy_controller фиксирует изменения в объектах enemy и в определенный момент их удаляет.
            Также он применен в классе Game, который следит за всеми изменениями и уведомляет о них другие классы.

Другие паттерны:
        - Game_loop (ну, наверно понятно, где))
        - Update Method (на каждый кадр обновляются объекты)

        При создании игры ориентировались на книгу "Game programming patterns" by Robert Nystrom